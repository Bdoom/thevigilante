#pragma kernel CSMain

// Thread group size
#define thread_group_size_x 16
#define thread_group_size_y 16
#define thread_group_size_z 1

float Speed = 1;
int wobble = 0;
float3 wind = float3(0, 0, 0);
float spacing = 5;
float3 worldPosition;
float areaScale;

// Structure to store particle data in. This is used to populate the outputBuffer
struct particleStruct
{
	float3 pos;
	float3 col;
	float2 scale;
	float timeStart;
};

// Structure to describe the data in the startPointBuffer
struct startYStruct
{
	float offset;
};

// Structure to describe the data in the constBuffer
struct constStruct
{
	float t;
};

struct posMod
{
	float2 mod;
};

// Compute Buffers
RWStructuredBuffer<posMod> modBuffer;
RWStructuredBuffer<constStruct> constBuffer;
RWStructuredBuffer<startYStruct> startPointBuffer;
RWStructuredBuffer<particleStruct> outputBuffer;

[numthreads(thread_group_size_x, thread_group_size_y, thread_group_size_z)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	int idx = id.x + id.y * thread_group_size_x * 32;
	float3 centre = float3(-(thread_group_size_x / 2) * 31, 0, -(thread_group_size_y / 2) * 31);
	float3 pos = (float3(id.x, id.z + (startPointBuffer[idx].offset), id.y) + centre) * spacing;

	pos.y = (lerp((spacing * 2) * 32, 0, (pos.y + (constBuffer[0].t * (modBuffer[idx].mod.x * Speed))) % 1)) * spacing;

	if (wobble)
	{
		pos.x += (cos(constBuffer[0].t * (modBuffer[idx].mod.x * 100))) * spacing;
		pos.z += (sin(constBuffer[0].t * (modBuffer[idx].mod.y * 100))) * spacing;
	}

	wind.y = 0; // Don't want the weather going up do we...
	//pos += (wind * constBuffer[0].t * 100);

	pos *= areaScale;

	outputBuffer[idx].pos = pos + worldPosition;
	outputBuffer[idx].col = float3(1, 1, 1);
	outputBuffer[idx].scale = float2(1, 8) * 0.04f;
}
